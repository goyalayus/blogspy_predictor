// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPendingURLs = `-- name: CountPendingURLs :one
SELECT count(*)::bigint FROM urls WHERE status IN ('pending_classification', 'pending_crawl')
`

func (q *Queries) CountPendingURLs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingURLs)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getCounterValue = `-- name: GetCounterValue :one
SELECT value FROM system_counters WHERE counter_name = $1
`

func (q *Queries) GetCounterValue(ctx context.Context, counterName string) (int64, error) {
	row := q.db.QueryRow(ctx, getCounterValue, counterName)
	var value int64
	err := row.Scan(&value)
	return value, err
}

const getExistingURLs = `-- name: GetExistingURLs :many
SELECT url FROM urls
WHERE url = ANY($1::text[])
`

func (q *Queries) GetExistingURLs(ctx context.Context, urls []string) ([]string, error) {
	rows, err := q.db.Query(ctx, getExistingURLs, urls)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var url string
		if err := rows.Scan(&url); err != nil {
			return nil, err
		}
		items = append(items, url)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalURLCount = `-- name: GetTotalURLCount :one
SELECT count(*)::bigint FROM urls
`

func (q *Queries) GetTotalURLCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalURLCount)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const lockJobsForUpdate = `-- name: LockJobsForUpdate :many

SELECT id, url FROM urls
WHERE status = $1
FOR UPDATE SKIP LOCKED
LIMIT $2
`

type LockJobsForUpdateParams struct {
	Status CrawlStatus
	Limit  int32
}

type LockJobsForUpdateRow struct {
	ID  int64
	Url string
}

// FILE: src/woker/query.sql
func (q *Queries) LockJobsForUpdate(ctx context.Context, arg LockJobsForUpdateParams) ([]LockJobsForUpdateRow, error) {
	rows, err := q.db.Query(ctx, lockJobsForUpdate, arg.Status, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LockJobsForUpdateRow
	for rows.Next() {
		var i LockJobsForUpdateRow
		if err := rows.Scan(&i.ID, &i.Url); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetStalledJobs = `-- name: ResetStalledJobs :execrows
UPDATE urls
SET
    status = CASE
        WHEN status = 'classifying'::crawl_status THEN 'pending_classification'::crawl_status
        WHEN status = 'crawling'::crawl_status THEN 'pending_crawl'::crawl_status
    END,
    locked_at = NULL
WHERE
    status IN ('classifying'::crawl_status, 'crawling'::crawl_status)
    AND locked_at < NOW() - $1::interval
`

func (q *Queries) ResetStalledJobs(ctx context.Context, timeoutInterval pgtype.Interval) (int64, error) {
	result, err := q.db.Exec(ctx, resetStalledJobs, timeoutInterval)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateCounterValue = `-- name: UpdateCounterValue :exec
UPDATE system_counters SET value = $1, updated_at = NOW() WHERE counter_name = $2
`

type UpdateCounterValueParams struct {
	Value       int64
	CounterName string
}

func (q *Queries) UpdateCounterValue(ctx context.Context, arg UpdateCounterValueParams) error {
	_, err := q.db.Exec(ctx, updateCounterValue, arg.Value, arg.CounterName)
	return err
}

const updateJobStatusToInProgress = `-- name: UpdateJobStatusToInProgress :exec
UPDATE urls
SET status = $1, locked_at = NOW()
WHERE id = ANY($2::bigint[])
`

type UpdateJobStatusToInProgressParams struct {
	Status CrawlStatus
	JobIds []int64
}

func (q *Queries) UpdateJobStatusToInProgress(ctx context.Context, arg UpdateJobStatusToInProgressParams) error {
	_, err := q.db.Exec(ctx, updateJobStatusToInProgress, arg.Status, arg.JobIds)
	return err
}
