// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPendingURLs = `-- name: CountPendingURLs :one
SELECT count(*)::bigint FROM urls WHERE status IN ('pending_classification', 'pending_crawl')
`

func (q *Queries) CountPendingURLs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingURLs)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getCounterValue = `-- name: GetCounterValue :one

SELECT value FROM system_counters WHERE counter_name = $1
`

// QUERIES FOR THE REAPER AND THROTTLING MECHANISM
func (q *Queries) GetCounterValue(ctx context.Context, counterName string) (int64, error) {
	row := q.db.QueryRow(ctx, getCounterValue, counterName)
	var value int64
	err := row.Scan(&value)
	return value, err
}

const getDomainDecisions = `-- name: GetDomainDecisions :many
SELECT DISTINCT ON (netloc) netloc, status
FROM urls
WHERE netloc = ANY($1::text[])
  AND status IN ('pending_crawl', 'crawling', 'completed', 'irrelevant')
`

type GetDomainDecisionsRow struct {
	Netloc string
	Status CrawlStatus
}

func (q *Queries) GetDomainDecisions(ctx context.Context, netlocs []string) ([]GetDomainDecisionsRow, error) {
	rows, err := q.db.Query(ctx, getDomainDecisions, netlocs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDomainDecisionsRow
	for rows.Next() {
		var i GetDomainDecisionsRow
		if err := rows.Scan(&i.Netloc, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExistingURLs = `-- name: GetExistingURLs :many
SELECT url FROM urls
WHERE url = ANY($1::text[])
`

func (q *Queries) GetExistingURLs(ctx context.Context, urls []string) ([]string, error) {
	rows, err := q.db.Query(ctx, getExistingURLs, urls)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var url string
		if err := rows.Scan(&url); err != nil {
			return nil, err
		}
		items = append(items, url)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNetlocCounts = `-- name: GetNetlocCounts :many
SELECT netloc, count(id)::int as count FROM urls
WHERE netloc = ANY($1::text[])
GROUP BY netloc
`

type GetNetlocCountsRow struct {
	Netloc string
	Count  int32
}

func (q *Queries) GetNetlocCounts(ctx context.Context, netlocs []string) ([]GetNetlocCountsRow, error) {
	rows, err := q.db.Query(ctx, getNetlocCounts, netlocs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNetlocCountsRow
	for rows.Next() {
		var i GetNetlocCountsRow
		if err := rows.Scan(&i.Netloc, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockJobsForUpdate = `-- name: LockJobsForUpdate :many

SELECT id, url FROM urls
WHERE status = $1
FOR UPDATE SKIP LOCKED
LIMIT $2
`

type LockJobsForUpdateParams struct {
	Status CrawlStatus
	Limit  int32
}

type LockJobsForUpdateRow struct {
	ID  int64
	Url string
}

// woker/query.sql
func (q *Queries) LockJobsForUpdate(ctx context.Context, arg LockJobsForUpdateParams) ([]LockJobsForUpdateRow, error) {
	rows, err := q.db.Query(ctx, lockJobsForUpdate, arg.Status, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LockJobsForUpdateRow
	for rows.Next() {
		var i LockJobsForUpdateRow
		if err := rows.Scan(&i.ID, &i.Url); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetStalledJobs = `-- name: ResetStalledJobs :exec
UPDATE urls
SET
    status = CASE
        WHEN status = 'classifying'::crawl_status THEN 'pending_classification'::crawl_status
        WHEN status = 'crawling'::crawl_status THEN 'pending_crawl'::crawl_status
    END,
    locked_at = NULL
WHERE
    status IN ('classifying'::crawl_status, 'crawling'::crawl_status)
    AND locked_at < NOW() - $1::interval
`

func (q *Queries) ResetStalledJobs(ctx context.Context, timeoutInterval pgtype.Interval) error {
	_, err := q.db.Exec(ctx, resetStalledJobs, timeoutInterval)
	return err
}

const updateCounterValue = `-- name: UpdateCounterValue :exec
UPDATE system_counters SET value = $1, updated_at = NOW() WHERE counter_name = $2
`

type UpdateCounterValueParams struct {
	Value       int64
	CounterName string
}

func (q *Queries) UpdateCounterValue(ctx context.Context, arg UpdateCounterValueParams) error {
	_, err := q.db.Exec(ctx, updateCounterValue, arg.Value, arg.CounterName)
	return err
}

const updateJobStatusToInProgress = `-- name: UpdateJobStatusToInProgress :exec
UPDATE urls
SET status = $1, locked_at = NOW()
WHERE id = ANY($2::bigint[])
`

type UpdateJobStatusToInProgressParams struct {
	Status CrawlStatus
	JobIds []int64
}

func (q *Queries) UpdateJobStatusToInProgress(ctx context.Context, arg UpdateJobStatusToInProgressParams) error {
	_, err := q.db.Exec(ctx, updateJobStatusToInProgress, arg.Status, arg.JobIds)
	return err
}

const updateStatus = `-- name: UpdateStatus :exec
UPDATE urls
SET status = $1, error_message = $2, processed_at = NOW()
WHERE id = $3
`

type UpdateStatusParams struct {
	Status       CrawlStatus
	ErrorMessage pgtype.Text
	ID           int64
}

func (q *Queries) UpdateStatus(ctx context.Context, arg UpdateStatusParams) error {
	_, err := q.db.Exec(ctx, updateStatus, arg.Status, arg.ErrorMessage, arg.ID)
	return err
}

const updateStatusAndRendering = `-- name: UpdateStatusAndRendering :exec
UPDATE urls
SET status = $1, rendering = $2, error_message = $3, processed_at = NOW()
WHERE id = $4
`

type UpdateStatusAndRenderingParams struct {
	Status       CrawlStatus
	Rendering    NullRenderingType
	ErrorMessage pgtype.Text
	ID           int64
}

func (q *Queries) UpdateStatusAndRendering(ctx context.Context, arg UpdateStatusAndRenderingParams) error {
	_, err := q.db.Exec(ctx, updateStatusAndRendering,
		arg.Status,
		arg.Rendering,
		arg.ErrorMessage,
		arg.ID,
	)
	return err
}

const updateURLAsCompleted = `-- name: UpdateURLAsCompleted :exec
UPDATE urls
SET status = $1, processed_at = NOW(), title = $2, description = $3, content = $4, rendering = $5
WHERE id = $6
`

type UpdateURLAsCompletedParams struct {
	Status      CrawlStatus
	Title       pgtype.Text
	Description pgtype.Text
	Content     pgtype.Text
	Rendering   NullRenderingType
	ID          int64
}

func (q *Queries) UpdateURLAsCompleted(ctx context.Context, arg UpdateURLAsCompletedParams) error {
	_, err := q.db.Exec(ctx, updateURLAsCompleted,
		arg.Status,
		arg.Title,
		arg.Description,
		arg.Content,
		arg.Rendering,
		arg.ID,
	)
	return err
}
